! Модуль содержит основные функции и сабрутины

module base

    implicit none

    private

    public basic_v1, basic_v2, basic_v3, noised_linspace, l2_norm, residual2, &
            y_coef_dr1_bp1, y_coef_dr1_bc0, y_coef_dr1_bcn, y_coef_dr2_bc0, y_coef_dr2_bcn, &
            f1, a1, p1, q1, f2, a2, p2, q2, f3, p3, q3, f4, p4, q4, f5, f6, q5, q6, p5, a3, k

    integer, parameter:: dp = kind(0.d0)

contains
    ! -----------------------------------------------------------------------------------------------------------------
    ! Базисная система вида
    ! φ0 = 0, φi(x) = x^i * (1 - x^2), i = 1, 2, ...
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function basic_v1(x, i, deriv_lvl) result(basic)

        implicit none

        real(dp), intent(in) :: x
        integer, intent(in) :: i, deriv_lvl

        if (i == 0) then
            basic = 0._dp
        else
            select case(deriv_lvl)
            case(0)
                basic = x ** i * (1 - x * x)
            case(1)
                basic = x ** (i - 1) * (i - x * (i + 1))
            case(2)
                basic = x ** (i - 2) * ((i * i - i) - x * x * (i + 1) * (i + 2))
            end select
        end if

    end function basic_v1
    ! -----------------------------------------------------------------------------------------------------------------
    ! Базисная система вида
    ! φ0 = 0, φ1(x) = 1 - x^2, φi(x) = x^i * (1 - x^2), i = 2, 3, ...
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function basic_v2(x, i, deriv_lvl) result(basic)

        implicit none

        real(dp), intent(in) :: x
        integer, intent(in) :: i, deriv_lvl

        if (i == 0) then
            basic = 0._dp
        else if (i == 1) then
            select case(deriv_lvl)
            case(0)
                basic = 1 - x * x
            case(1)
                basic = -2 * x
            case(2)
                basic = -2
            end select
        else
            select case(deriv_lvl)
            case(0)
                basic = x ** i * (1 - x * x)
            case(1)
                basic = x ** (i - 1) * (i - x * (i + 1))
            case(2)
                basic = x ** (i - 2) * ((i * i - i) - x * x * (i + 1) * (i + 2))
            end select
        end if

    end function basic_v2
    ! -----------------------------------------------------------------------------------------------------------------
    ! Базисная система вида
    ! φ0 = 0, φi(x) = x^i * (1 - x), i = 1, 2, ..
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function basic_v3(x, i, deriv_lvl) result(basic)

        implicit none

        real(dp), intent(in) :: x
        integer, intent(in) :: i, deriv_lvl

        if (i == 0) then
            basic = 0._dp
        else
            select case(deriv_lvl)
            case(0)
                basic = x ** i * (1 - x)
            case(1)
                basic = i * (1 - x) * (x ** (i - 1)) - (x ** i)
            case(2)
                basic = (i - 1) * i * (1 - x) * (x ** (i - 2)) - (2 * i * x ** (i - 1))
            end select
        end if

    end function basic_v3
    ! -----------------------------------------------------------------------------------------------------------------
    ! Равномерное разбиение с учетом крайних шумов
    ! -----------------------------------------------------------------------------------------------------------------
    subroutine noised_linspace(from, to, array, noise)

        implicit none

        real(dp), intent(in) :: from, to, noise
        real(dp), intent(out) :: array(:)

        real(dp) :: range
        integer :: n, i

        n = size(array)
        range = (to-noise) - (from+noise)

        if (n == 0) return

        if (n == 1) then
            array(1) = from+noise
            return
        end if

        do i = 1, n
            array(i) = (from+noise) + range * (i - 1) / (n - 1)

            ! во избежание деления на 0
            if (array(i) == 0) then
                array(i) = 1e-8
            end if

        end do

        return

    end
    ! -----------------------------------------------------------------------------------------------------------------
    ! L2 норма (погрешность, для вычисления интеграла используется метод трапеций)
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function l2_norm(func, x0, x1, n, aa, f, a, p, q, basic, div_no) result(l2)

        implicit none

        real(dp), external :: func, basic, f, p, q, a

        real(dp), intent(in) :: x0, x1, aa(1:n)
        integer, intent(in) :: div_no, n

        real(dp) :: x, dx
        integer :: l

        dx = (x1 - x0) / div_no
        l2 = func(x0, n, aa, f, a, p, q, basic) + func(x1, n, aa, f, a, p, q, basic)
        x = x0

        do l = 1, div_no - 1
            x = x + dx
            l2 = l2 + 2.0 * func(x, n, aa, f, a, p, q, basic)
        end do
        l2 = sqrt(dx * l2 / 2.0)

    end function l2_norm
    ! -----------------------------------------------------------------------------------------------------------------
    ! Квадрат невязки (для вычисления погрешности в методах коллокаций, Галеркина, наименьших квадратов)
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function residual2(x, n, aa, f, a, p, q, basic) result(sum)

        implicit none

        real(dp), external :: basic, f, p, q, a

        real(dp), intent(in) :: x, aa(1:n)
        integer, intent(in) :: n

        integer :: i, j

        sum = a(x) * basic(x, 0, 2) + p(x) * basic(x, 0, 1) + q(x) * basic(x, 0, 0)
        do i = 2, n
            sum = sum + aa(i) * (a(x) * basic(x, i-1, 2) + p(x) * basic(x, i-1, 1) + q(x) * basic(x, i-1, 0))
        end do

        sum = (sum - f(x)) ** 2

    end function residual2
    ! -----------------------------------------------------------------------------------------------------------------
    ! Краевая задача вида (bp1)
    ! a(x)y'' + p(x)y' + q(x)y = f(x)
    !
    ! Разностные отношения вида (dr1)
    ! 1. y(x(k)) = y(k)
    ! 2. y'(x(k)) = (y(k+1) - y(k-1)) / 2h
    ! 3. y''(x(k)) = (y(k+1) - 2y(k) + y(k-1)) / h / h
    !
    ! Следовательно, полученные коэффициенты:
    ! (2a(x) + p(x)h) / 2h^2     при y(k+1) => lvl = 2
    ! (2q(x)h^2 - 4a(x)) / 2h^2  при y(k)   => lvl = 1
    ! (2a(x)-p(x)h) / 2h^2       при y(k-1) => lvl = 0
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function y_coef_dr1_bp1(x, h, a, p, q, lvl)

        implicit none

        real(dp), intent(in) :: x, h
        real(dp), external :: p, q, a
        integer, intent(in) :: lvl

        select case(lvl)
        case(0)
            y_coef_dr1_bp1 = (2 * a(x) - p(x) * h) / 2 / h / h
        case(1)
            y_coef_dr1_bp1 = (2 * q(x) * h * h - 4 * a(x)) / 2 / h / h
        case(2)
            y_coef_dr1_bp1 = (2 * a(x) + p(x) * h) / 2 / h / h
        end select

    end function y_coef_dr1_bp1
    ! -----------------------------------------------------------------------------------------------------------------
    ! Граничные условия вида (bc0)
    ! alpha1 * y(x_min) + beta1 * y'(x_min) = AA
    !
    ! Разностные отношения вида (dr1)
    ! y'(0) = (-y(2) + 4y(1) - 3y(0)) / 2h
    !
    ! Следовательно, полученные коэффициенты:
    ! (-beta1) / 2h                    при y(2)   => lvl = 2
    ! 4 * beta1 / 2h                   при y(1)   => lvl = 1
    ! (2h * alpha1 - 3 * beta1) / 2h   при y(0)   => lvl = 0
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function y_coef_dr1_bc0(h, alpha1, beta1, lvl)

        implicit none

        real(dp), intent(in) :: h, alpha1, beta1
        integer, intent(in) :: lvl

        select case(lvl)
        case(0)
            y_coef_dr1_bc0 = (2 * h * alpha1 - 3 * beta1) / 2 / h
        case(1)
            y_coef_dr1_bc0 = 4 * beta1 / 2 / h
        case(2)
            y_coef_dr1_bc0 = (-beta1) / 2 / h
        end select

    end function y_coef_dr1_bc0
    ! -----------------------------------------------------------------------------------------------------------------
    ! Граничные условия вида (bc0)
    ! alpha1 * y(x_min) + beta1 * y'(x_min) = AA
    !
    ! Разностные отношения вида (dr2) - метод баланса
    ! Коэффициенты:
    ! 0                          при y(2)   => lvl = 2
    ! beta1 / h                  при y(1)   => lvl = 1
    ! (h * apha1 - beta1) / h    при y(0)   => lvl = 0
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function y_coef_dr2_bc0(h, alpha1, beta1, lvl)

        implicit none

        real(dp), intent(in) :: h, alpha1, beta1
        integer, intent(in) :: lvl

        select case(lvl)
        case(0)
            y_coef_dr2_bc0 = (h * alpha1 - beta1) / h
        case(1)
            y_coef_dr2_bc0 = beta1 / h
        case(2)
            y_coef_dr2_bc0 = 0._dp
        end select

    end function y_coef_dr2_bc0
    ! -----------------------------------------------------------------------------------------------------------------
    ! Граничные условия вида (bcn)
    ! alpha2 * y(x_max) + beta2 * y'(x_max) = BB
    !
    ! Разностные отношения вида (dr1)
    ! y'(n) = (3y(n) - 4y(n-1) + y(n-2)) / 2h
    !
    ! Следовательно, полученные коэффициенты:
    ! (2h * alpha2 + 3 * beta2) / 2h    при y(n)   => lvl = 2
    ! -4 * beta2 / 2h                   при y(n-1)   => lvl = 1
    ! beta2 / 2h                        при y(n-2)   => lvl = 0
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function y_coef_dr1_bcn(h, alpha2, beta2, lvl)

        implicit none

        real(dp), intent(in) :: h, alpha2, beta2
        integer, intent(in) :: lvl

        select case(lvl)
        case(0)
            y_coef_dr1_bcn = beta2 / 2 / h
        case(1)
            y_coef_dr1_bcn = -4 * beta2 / 2 / h
        case(2)
            y_coef_dr1_bcn = (2 * h * alpha2 + 3 * beta2) / 2 / h
        end select

    end function y_coef_dr1_bcn
    ! -----------------------------------------------------------------------------------------------------------------
    ! Граничные условия вида (bcn)
    ! alpha2 * y(x_max) + beta2 * y'(x_max) = BB
    !
    ! Разностные отношения вида (dr2) - метод баланса
    ! Коэффициенты:
    ! (beta2 + alpha2 * h) / h   при y(n)     => lvl = 2
    ! -beta2 / h                 при y(n-1)   => lvl = 1
    ! 0                          при y(n-2)   => lvl = 0
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function y_coef_dr2_bcn(h, alpha2, beta2, lvl)

        implicit none

        real(dp), intent(in) :: h, alpha2, beta2
        integer, intent(in) :: lvl

        select case(lvl)
        case(0)
            y_coef_dr2_bcn = 0._dp
        case(1)
            y_coef_dr2_bcn = -beta2 / h
        case(2)
            y_coef_dr2_bcn = (beta2 + alpha2 * h) / h
        end select

    end function y_coef_dr2_bcn
    ! -----------------------------------------------------------------------------------------------------------------
    ! f1(x) - правая часть уравнения
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function f1(x)

        implicit none
        real(dp), intent(in) :: x

        f1 = 5 * (1 - x * x)

    end function f1
    ! -----------------------------------------------------------------------------------------------------------------
    ! f2(x) - правая часть уравнения
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function f2(x)

        implicit none
        real(dp), intent(in) :: x

        f2 = -1

    end function f2
    ! -----------------------------------------------------------------------------------------------------------------
    ! f3(x) - правая часть уравнения
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function f3(x)

        implicit none
        real(dp), intent(in) :: x

        f3 = 8

    end function f3
    ! -----------------------------------------------------------------------------------------------------------------
    ! f4(x) - правая часть уравнения
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function f4(x)

        implicit none
        real(dp), intent(in) :: x

        f4 = 6 / (x ** 4) - 3 / x

    end function f4
    ! -----------------------------------------------------------------------------------------------------------------
    ! f5(x) - правая часть уравнения
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function f5(x)

        implicit none
        real(dp), intent(in) :: x

        f5 = x * x

    end function f5
    ! -----------------------------------------------------------------------------------------------------------------
    ! f6(x) - правая часть уравнения
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function f6(x)

        implicit none
        real(dp), intent(in) :: x

        f6 = 8 * x * (2.5 - x)

    end function f6
    ! -----------------------------------------------------------------------------------------------------------------
    ! p1(x) - коэффициент при y'
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function p1(x)

        implicit none
        real(dp), intent(in) :: x

        p1 = -0.5 + SIN(x)

    end function p1
    ! -----------------------------------------------------------------------------------------------------------------
    ! p2(x) - коэффициент при y'
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function p2(x)

        implicit none
        real(dp), intent(in) :: x

        p2 = 0._dp

    end function p2
    ! -----------------------------------------------------------------------------------------------------------------
    ! p3(x) - коэффициент при y'
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function p3(x)

        implicit none
        real(dp), intent(in) :: x

        p3 = -3._dp

    end function p3
    ! -----------------------------------------------------------------------------------------------------------------
    ! p4(x) - коэффициент при y'
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function p4(x)

        implicit none
        real(dp), intent(in) :: x

        p4 = x * x

    end function p4
    ! -----------------------------------------------------------------------------------------------------------------
    ! p5(x) - коэффициент при y'
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function p5(x)

        implicit none
        real(dp), intent(in) :: x

        p5 = EXP(x)

    end function p5
    ! -----------------------------------------------------------------------------------------------------------------
    ! q1(x) - коэффициент при y
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function q1(x)

        implicit none
        real(dp), intent(in) :: x

        q1 = 8 / (1 + 0.25 * x * x)

    end function q1
    ! -----------------------------------------------------------------------------------------------------------------
    ! q2(x) - коэффициент при y
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function q2(x)

        implicit none
        real(dp), intent(in) :: x
        real(dp), parameter :: PI = 3.1415926535897932_dp, K = 12._dp

        q2 = 1 + COS(K) * x * x

    end function q2
    ! -----------------------------------------------------------------------------------------------------------------
    ! q3(x) - коэффициент при y
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function q3(x)

        implicit none
        real(dp), intent(in) :: x

        q3 = 8 * x

    end function q3
    ! -----------------------------------------------------------------------------------------------------------------
    ! q4(x) - коэффициент при y
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function q4(x)

        implicit none
        real(dp), intent(in) :: x

        q4 = -x

    end function q4
    ! -----------------------------------------------------------------------------------------------------------------
    ! q5(x) - коэффициент при y
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function q5(x)

        implicit none
        real(dp), intent(in) :: x

        q5 = x / 2

    end function q5
    ! -----------------------------------------------------------------------------------------------------------------
    ! q6(x) - коэффициент при y
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function q6(x)

        implicit none
        real(dp), intent(in) :: x

        if (x >= 0 .and. x <= 1.125) then
            q6 = 6.5
        elseif (x > 1.125 .and. x <= 2) then
            q6 = 7.8
        end if

    end function q6
    ! -----------------------------------------------------------------------------------------------------------------
    ! a1(x) - коэффициент при y''
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function a1(x)

        implicit none
        real(dp), intent(in) :: x

        a1 = 1

    end function a1
    ! -----------------------------------------------------------------------------------------------------------------
    ! a2(x) - коэффициент при y''
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function a2(x)

        implicit none
        real(dp), intent(in) :: x
        real(dp), parameter :: K = 12._dp

        a2 = SIN(K)

    end function a2
    ! -----------------------------------------------------------------------------------------------------------------
    ! a3(x) - коэффициент при y''
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function a3(x)

        implicit none
        real(dp), intent(in) :: x

        a3 = -k(x)

    end function a3
    ! -----------------------------------------------------------------------------------------------------------------
    ! k(x)
    ! -----------------------------------------------------------------------------------------------------------------
    real(dp) function k(x)

        implicit none
        real(dp), intent(in) :: x

        if (x >= 0 .and. x <= 1.125) then
            k = 1.8
        elseif (x > 1.125 .and. x <= 2) then
            k = 0.6
        end if

    end function k

end module base
